#!/bin/sh
# Smart Bridge Auto-Handler Script
# à¤¸à¥à¤®à¤¾à¤°à¥à¤Ÿ à¤¬à¥à¤°à¤¿à¤œ à¤‘à¤Ÿà¥‹-à¤¹à¥ˆà¤‚à¤¡à¤²à¤° - à¤¸à¤­à¥€ à¤¸à¤®à¤¸à¥à¤¯à¤¾à¤“à¤‚ à¤•à¤¾ automatic à¤¸à¤®à¤¾à¤§à¤¾à¤¨
# Automatically handles WDS, relayd, DHCP relay, and all bridge issues

SCRIPT_NAME="smart_bridge_handler"
LOG_FILE="/var/log/smart_bridge_handler.log"
PID_FILE="/var/run/${SCRIPT_NAME}.pid"
CHECK_INTERVAL=15  # seconds
WDS_CHECK_TIMEOUT=30
DHCP_TEST_TIMEOUT=60

# Status tracking
CURRENT_BRIDGE_MODE=""
WIFI_INTERFACE=""
ETHERNET_INTERFACE="eth0"
BRIDGE_INTERFACE="br_master"
USB_INTERFACES=""
RELAYD_ACTIVE=0
WDS_SUPPORTED=0

# Logging function
log_msg() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$$] $1" | tee -a "$LOG_FILE"
}

# Check if already running
check_running() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            log_msg "âš ï¸ Smart bridge handler already running (PID: $pid)"
            exit 1
        else
            rm -f "$PID_FILE"
        fi
    fi
}

# Create PID file
create_pid() {
    echo $$ > "$PID_FILE"
    log_msg "ğŸš€ Smart Bridge Auto-Handler started (PID: $$)"
}

# Signal handler for clean exit
cleanup() {
    log_msg "ğŸ›‘ Smart bridge handler stopping..."
    rm -f "$PID_FILE"
    exit 0
}

trap cleanup TERM INT

# Detect WiFi interface
detect_wifi_interface() {
    for iface in $(ls /sys/class/net/ 2>/dev/null); do
        if [ -d "/sys/class/net/$iface/wireless" ]; then
            WIFI_INTERFACE="$iface"
            log_msg "ğŸ“¡ WiFi interface detected: $WIFI_INTERFACE"
            return 0
        fi
    done
    
    log_msg "âŒ No WiFi interface found"
    return 1
}

# Check if interface supports WDS/4addr
check_wds_support() {
    local iface="$1"
    
    if [ -z "$iface" ]; then
        return 1
    fi
    
    log_msg "ğŸ” Checking WDS/4addr support on $iface"
    
    # Try to enable 4addr mode
    iw dev "$iface" set 4addr on 2>/dev/null
    if [ $? -eq 0 ]; then
        log_msg "âœ… WDS/4addr supported on $iface"
        WDS_SUPPORTED=1
        return 0
    else
        log_msg "âŒ WDS/4addr not supported on $iface"
        WDS_SUPPORTED=0
        return 1
    fi
}

# Test DHCP relay functionality
test_dhcp_relay() {
    log_msg "ğŸ§ª Testing DHCP relay functionality"
    
    # Check if we can get IP on bridge interface
    local timeout=0
    while [ $timeout -lt $DHCP_TEST_TIMEOUT ]; do
        if ip addr show "$BRIDGE_INTERFACE" | grep -q "inet "; then
            local bridge_ip=$(ip addr show "$BRIDGE_INTERFACE" | grep "inet " | awk '{print $2}' | cut -d'/' -f1)
            log_msg "âœ… DHCP relay working - Bridge IP: $bridge_ip"
            return 0
        fi
        
        sleep 5
        timeout=$((timeout + 5))
    done
    
    log_msg "âŒ DHCP relay not working within $DHCP_TEST_TIMEOUT seconds"
    return 1
}

# Install and configure relayd for pseudo-bridge
setup_relayd_pseudo_bridge() {
    log_msg "âš™ï¸ Setting up relayd pseudo-bridge"
    
    # Install relayd if not present
    if ! opkg list-installed | grep -q "relayd"; then
        log_msg "ğŸ“¦ Installing relayd package"
        opkg update >/dev/null 2>&1
        opkg install relayd >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            log_msg "âŒ Failed to install relayd package"
            return 1
        fi
    fi
    
    log_msg "âœ… relayd package available"
    
    # Stop existing relayd
    /etc/init.d/relayd stop 2>/dev/null || true
    
    # Configure relayd
    uci delete network.relayd 2>/dev/null || true
    uci set network.relayd=relay
    uci set network.relayd.proto='relay'
    uci set network.relayd.ipaddr='192.168.1.1'
    uci set network.relayd.netmask='255.255.255.0'
    
    # Add interfaces to relay
    uci delete network.relayd.network 2>/dev/null || true
    if [ -n "$WIFI_INTERFACE" ]; then
        uci add_list network.relayd.network="wifi_client"
    fi
    uci add_list network.relayd.network="lan"
    
    # Configure WiFi client network for relayd
    if [ -n "$WIFI_INTERFACE" ]; then
        uci set network.wifi_client=interface
        uci set network.wifi_client.proto='none'
        uci set network.wifi_client.ifname="$WIFI_INTERFACE"
    fi
    
    # Configure LAN network for relayd
    uci set network.lan.proto='none'
    uci set network.lan.ifname="$ETHERNET_INTERFACE"
    
    uci commit network
    
    # Restart network and relayd
    /etc/init.d/network restart
    sleep 5
    
    /etc/init.d/relayd enable
    /etc/init.d/relayd start
    
    if /etc/init.d/relayd status >/dev/null 2>&1; then
        log_msg "âœ… relayd pseudo-bridge configured successfully"
        RELAYD_ACTIVE=1
        CURRENT_BRIDGE_MODE="relayd_pseudo"
        return 0
    else
        log_msg "âŒ Failed to start relayd service"
        return 1
    fi
}

# Setup true L2 bridge with WDS
setup_wds_true_bridge() {
    log_msg "âš™ï¸ Setting up WDS true L2 bridge"
    
    if [ -z "$WIFI_INTERFACE" ]; then
        log_msg "âŒ No WiFi interface for WDS bridge"
        return 1
    fi
    
    # Enable 4addr mode on WiFi interface
    iw dev "$WIFI_INTERFACE" set 4addr on
    
    # Remove existing bridge configuration
    brctl delif "$BRIDGE_INTERFACE" "$WIFI_INTERFACE" 2>/dev/null || true
    
    # Add WiFi interface to bridge
    brctl addif "$BRIDGE_INTERFACE" "$WIFI_INTERFACE"
    
    # Bring up interface
    ip link set dev "$WIFI_INTERFACE" up
    
    log_msg "âœ… WDS true L2 bridge configured"
    CURRENT_BRIDGE_MODE="wds_true"
    return 0
}

# Setup standard bridge without WiFi (USB + Ethernet only)
setup_standard_bridge() {
    log_msg "âš™ï¸ Setting up standard bridge (USB + Ethernet only)"
    
    # Stop relayd if active
    if [ $RELAYD_ACTIVE -eq 1 ]; then
        /etc/init.d/relayd stop 2>/dev/null || true
        /etc/init.d/relayd disable 2>/dev/null || true
        RELAYD_ACTIVE=0
    fi
    
    # Configure simple bridge
    uci set network.lan=interface
    uci set network.lan.proto='none'
    uci set network.lan.type='bridge'
    uci set network.lan.ifname="$ETHERNET_INTERFACE"
    
    # Add USB interfaces if available
    for usb_if in $USB_INTERFACES; do
        if ip link show "$usb_if" >/dev/null 2>&1; then
            uci add_list network.lan.ifname="$usb_if"
            log_msg "â• Added $usb_if to bridge"
        fi
    done
    
    uci commit network
    /etc/init.d/network restart
    
    log_msg "âœ… Standard bridge configured"
    CURRENT_BRIDGE_MODE="standard"
    return 0
}

# Detect active USB tethering interfaces
detect_usb_interfaces() {
    USB_INTERFACES=""
    
    for iface in $(ls /sys/class/net/ 2>/dev/null); do
        local device_path="/sys/class/net/$iface/device"
        
        if [ -L "$device_path" ]; then
            local usb_path=$(readlink -f "$device_path" 2>/dev/null)
            if echo "$usb_path" | grep -q "/usb"; then
                USB_INTERFACES="$USB_INTERFACES $iface"
                log_msg "ğŸ”Œ USB interface detected: $iface"
            fi
        fi
    done
}

# Check if WiFi is connected to a hotspot
check_wifi_connection() {
    if [ -z "$WIFI_INTERFACE" ]; then
        return 1
    fi
    
    # Check if interface is up and connected
    if ip link show "$WIFI_INTERFACE" | grep -q "state UP"; then
        # Check if we have an IP or are associated
        if iw dev "$WIFI_INTERFACE" link 2>/dev/null | grep -q "Connected to"; then
            local ssid=$(iw dev "$WIFI_INTERFACE" link 2>/dev/null | grep "SSID" | awk '{print $2}')
            log_msg "ğŸ“¡ WiFi connected to: $ssid"
            return 0
        fi
    fi
    
    return 1
}

# Auto-configure optimal bridge mode
auto_configure_bridge() {
    log_msg "ğŸ”„ Auto-configuring optimal bridge mode"
    
    # Detect interfaces
    detect_wifi_interface
    detect_usb_interfaces
    
    # Determine best bridge configuration
    if check_wifi_connection; then
        log_msg "ğŸ“¡ WiFi connection detected, testing bridge compatibility"
        
        # Test WDS support
        if check_wds_support "$WIFI_INTERFACE"; then
            log_msg "ğŸ¯ Configuring WDS true L2 bridge"
            if setup_wds_true_bridge; then
                return 0
            fi
        fi
        
        # WDS failed or not supported, try relayd pseudo-bridge
        log_msg "ğŸ”„ WDS failed, configuring relayd pseudo-bridge"
        if setup_relayd_pseudo_bridge; then
            return 0
        fi
        
        # Both failed, use standard bridge
        log_msg "âš ï¸ Advanced bridging failed, using standard bridge"
        setup_standard_bridge
        
    elif [ -n "$USB_INTERFACES" ]; then
        log_msg "ğŸ”Œ Only USB interfaces detected, using standard bridge"
        setup_standard_bridge
        
    else
        log_msg "âŒ No internet sources detected"
        return 1
    fi
}

# Monitor and maintain bridge configuration
monitor_bridge() {
    log_msg "ğŸ‘€ Monitoring bridge configuration"
    
    while true; do
        # Check if current configuration is still optimal
        local wifi_connected=0
        local usb_connected=0
        
        if check_wifi_connection; then
            wifi_connected=1
        fi
        
        detect_usb_interfaces
        if [ -n "$USB_INTERFACES" ]; then
            usb_connected=1
        fi
        
        # Determine if reconfiguration is needed
        local needs_reconfig=0
        
        case "$CURRENT_BRIDGE_MODE" in
            "wds_true")
                if [ $wifi_connected -eq 0 ]; then
                    log_msg "ğŸ“¡ WiFi disconnected, need reconfiguration"
                    needs_reconfig=1
                fi
                ;;
            "relayd_pseudo")
                if [ $wifi_connected -eq 0 ]; then
                    log_msg "ğŸ“¡ WiFi disconnected, need reconfiguration"
                    needs_reconfig=1
                elif [ $RELAYD_ACTIVE -eq 1 ] && ! /etc/init.d/relayd status >/dev/null 2>&1; then
                    log_msg "ğŸ”„ relayd service died, restarting"
                    /etc/init.d/relayd start
                fi
                ;;
            "standard")
                if [ $wifi_connected -eq 1 ]; then
                    log_msg "ğŸ“¡ WiFi connected, checking for better bridge mode"
                    needs_reconfig=1
                fi
                ;;
        esac
        
        if [ $needs_reconfig -eq 1 ]; then
            log_msg "ğŸ”„ Reconfiguring bridge due to connection changes"
            auto_configure_bridge
        fi
        
        # Test DHCP functionality periodically
        if [ $(($(date +%s) % 300)) -eq 0 ]; then  # Every 5 minutes
            case "$CURRENT_BRIDGE_MODE" in
                "relayd_pseudo")
                    if ! test_dhcp_relay; then
                        log_msg "ğŸ”„ DHCP relay failed, reconfiguring"
                        auto_configure_bridge
                    fi
                    ;;
            esac
        fi
        
        sleep "$CHECK_INTERVAL"
    done
}

# Handle different IP ranges from mobile devices
handle_mobile_ip_ranges() {
    log_msg "ğŸŒ Configuring mobile IP range compatibility"
    
    # Common mobile IP ranges
    local mobile_ranges="192.168.42.0/24 192.168.43.0/24 172.20.10.0/28 192.168.137.0/24"
    
    # Add routes for common mobile ranges
    for range in $mobile_ranges; do
        ip route add "$range" dev "$BRIDGE_INTERFACE" 2>/dev/null || true
    done
    
    # Configure bridge to accept different IP ranges
    echo 0 > /proc/sys/net/ipv4/conf/"$BRIDGE_INTERFACE"/rp_filter 2>/dev/null || true
    echo 1 > /proc/sys/net/ipv4/conf/"$BRIDGE_INTERFACE"/proxy_arp 2>/dev/null || true
}

# Optimize bridge performance
optimize_bridge_performance() {
    log_msg "âš¡ Optimizing bridge performance"
    
    # Enable hardware offloading if available
    ethtool -K "$ETHERNET_INTERFACE" gso on 2>/dev/null || true
    ethtool -K "$ETHERNET_INTERFACE" gro on 2>/dev/null || true
    
    # Optimize bridge settings
    echo 0 > "/sys/class/net/$BRIDGE_INTERFACE/bridge/ageing_time" 2>/dev/null || true
    echo 0 > "/sys/class/net/$BRIDGE_INTERFACE/bridge/forward_delay" 2>/dev/null || true
    echo 2 > "/sys/class/net/$BRIDGE_INTERFACE/bridge/hello_time" 2>/dev/null || true
    
    # Optimize network stack
    echo 1 > /proc/sys/net/ipv4/ip_forward
    echo 0 > /proc/sys/net/ipv4/conf/all/rp_filter
    echo 1 > /proc/sys/net/bridge/bridge-nf-call-iptables 2>/dev/null || true
}

# Main function
main() {
    check_running
    create_pid
    
    log_msg "ğŸš€ Smart Bridge Auto-Handler starting"
    log_msg "ğŸ”§ Check interval: ${CHECK_INTERVAL}s"
    
    # Initial configuration
    handle_mobile_ip_ranges
    optimize_bridge_performance
    auto_configure_bridge
    
    # Start monitoring loop
    monitor_bridge
}

# Command line interface
case "$1" in
    start)
        main
        ;;
    stop)
        if [ -f "$PID_FILE" ]; then
            local pid=$(cat "$PID_FILE")
            if kill "$pid" 2>/dev/null; then
                log_msg "ğŸ›‘ Smart bridge handler stopped (PID: $pid)"
            fi
            rm -f "$PID_FILE"
        else
            log_msg "âš ï¸ Smart bridge handler not running"
        fi
        ;;
    restart)
        $0 stop
        sleep 2
        $0 start
        ;;
    status)
        if [ -f "$PID_FILE" ]; then
            local pid=$(cat "$PID_FILE")
            if kill -0 "$pid" 2>/dev/null; then
                echo "âœ… Smart bridge handler is running (PID: $pid)"
                echo "ğŸŒ‰ Current bridge mode: ${CURRENT_BRIDGE_MODE:-Unknown}"
                echo "ğŸ“‹ Log file: $LOG_FILE"
                return 0
            else
                echo "âŒ PID file exists but process not running"
                rm -f "$PID_FILE"
                return 1
            fi
        else
            echo "â­• Smart bridge handler is not running"
            return 1
        fi
        ;;
    configure)
        detect_wifi_interface
        detect_usb_interfaces  
        handle_mobile_ip_ranges
        optimize_bridge_performance
        auto_configure_bridge
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status|configure}"
        echo ""
        echo "ğŸ§  Smart Bridge Auto-Handler"
        echo "ğŸ“‹ Commands:"
        echo "   start     - Start intelligent bridge monitoring"
        echo "   stop      - Stop bridge handler"
        echo "   restart   - Restart bridge handler"
        echo "   status    - Check service status"
        echo "   configure - One-time bridge configuration"
        echo ""
        echo "ğŸ¯ Auto-handles: WDS, relayd, DHCP relay, mobile IP ranges"
        exit 1
        ;;
esac